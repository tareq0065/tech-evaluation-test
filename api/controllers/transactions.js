import { dirname, resolve } from "path";
import { fileURLToPath } from "url";
import fs from "fs";

// Demo valid types (case-sensitive)
const VALID_TYPES = ["Stake", "Borrow", "Lend"];

// Demo valid statuses
const VALID_STATUSES = ["pending", "completed", "failed"];

// Polyfill __dirname in ESM
const __dirname = dirname(fileURLToPath(import.meta.url));

// Path to your data file
const DATA_FILE = resolve(__dirname, "../transactions.json");

// Load transactions into memory on server start
let transactions = [];
if (fs.existsSync(DATA_FILE)) {
	transactions = JSON.parse(fs.readFileSync(DATA_FILE, "utf-8"));
}

// Save helper
const saveTransactions = () => {
	fs.writeFileSync(DATA_FILE, JSON.stringify(transactions, null, 2), "utf-8");
};

/**
 * GET /api/transactions
 * ---------------------
 * Retrieve a list of all transactions.
 *
 * Optional Query Parameters:
 * - type: Filter transactions by type. Valid values are "Stake", "Borrow", or "Lend".
 * - status: Filter transactions by status ("pending", "completed", "failed")
 *
 * Success Response:
 * - 200 OK: Returns an array of transactions (filtered if query param is used).
 *
 * Error Response:
 * - 400 Bad Request: Returned if an invalid type or status value is provided.
 */
export const index = (req, res) => {
	const { type, status, page = 1, pageSize = 5 } = req.query;
	
	let filtered = transactions;
	
	if (type) {
		if (!VALID_TYPES.includes(type)) {
			return res.status(400).json({ error: "Invalid type. Valid values are 'Stake', 'Borrow', or 'Lend'." });
		}
		filtered = filtered.filter(tx => tx.transactionType === type);
	}
	
	if (status) {
		if (!VALID_STATUSES.includes(status)) {
			return res.status(400).json({ error: "Invalid status. Valid values are 'pending', 'completed', or 'failed'." });
		}
		filtered = filtered.filter(tx => tx.status === status);
	}
	
	// Pagination logic
	const pageNum = Math.max(1, parseInt(page));
	const sizeNum = Math.max(1, parseInt(pageSize));
	const total = filtered.length;
	const totalPages = Math.ceil(total / sizeNum);
	const paginated = filtered.slice((pageNum - 1) * sizeNum, pageNum * sizeNum);
	
	return res.status(200).json({
		data: paginated,
		page: pageNum,
		pageSize: sizeNum,
		total,
		totalPages
	});
};


/**
 * GET /api/transactions/:id
 * -------------------------
 * Retrieve a specific transaction by its ID.
 *
 * URL Parameters:
 * - id: The unique identifier of the transaction to retrieve.
 *
 * Success Response:
 * - 200 OK: Returns the transaction object.
 *
 * Error Response:
 * - 404 Not Found: Returned if no transaction exists with the given ID.
 */
export const fetchById = (req, res) => {
	const { id } = req.params;
	const tx = transactions.find(tx => tx.id === id);
	
	if (!tx) {
		return res.status(404).json({ error: "Transaction not found" });
	}
	
	return res.status(200).json(tx);
}

/**
 * POST /api/transactions
 * ----------------------
 * Create a new transaction.
 *
 * Request Body:
 * - transactionType (string): Must be one of "Stake", "Borrow", or "Lend".
 * - token (string): Must be a non-empty string.
 * - amount (number): Must be a positive number.
 * - status (string): Optional. Valid values are "pending", "completed", or "failed". Default is "pending".
 * - description (string): Optional. Default is an empty string.
 * - Note: The 'id' is generated by the backend and should not be included in the request.
 *
 * Success Response:
 * - 201 Created: Returns the newly created transaction object.
 *
 * Error Response:
 * - 400 Bad Request: Returned if validation fails (e.g., invalid type, empty token, or non-positive amount).
 */
export const create = (req, res) => {
	const { transactionType, token, amount, status, description } = req.body;
	
	// Validate transaction type
	if (!VALID_TYPES.includes(transactionType)) {
		return res.status(400).json({ error: "Invalid transaction type. Must be 'Stake', 'Borrow', or 'Lend'." });
	}
	// Validate token
	if (!token || typeof token !== "string" || token.trim() === "") {
		return res.status(400).json({ error: "Token is required and must be a non-empty string." });
	}
	// Validate amount
	if (typeof amount !== "number" || amount <= 0) {
		return res.status(400).json({ error: "Amount must be a positive number." });
	}
	// Validate status (if present)
	let finalStatus = "pending";
	if (status !== undefined) {
		if (!VALID_STATUSES.includes(status)) {
			return res.status(400).json({ error: "Invalid status. Must be 'pending', 'completed', or 'failed'." });
		}
		finalStatus = status;
	}
	// Validate description (if present)
	let finalDescription = "";
	if (description !== undefined) {
		if (typeof description !== "string") {
			return res.status(400).json({ error: "Description must be a string." });
		}
		finalDescription = description;
	}
	
	// Generate ID and timestamp
	const id = Date.now().toString();
	const date = new Date().toISOString();
	const tx = {
		id,
		username: req.body.username || "demo",
		transactionType,
		token,
		amount,
		date,
		status: finalStatus,
		description: finalDescription
	};
	
	transactions.push(tx);
	saveTransactions(); // Save to file!
	
	return res.status(201).json(tx);
}
